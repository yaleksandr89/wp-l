## Вопросы по уроку ##

Пользовательский тип записи создал для [портфолио](https://wp.alexanderyurchenko.ru/portfolio)

### Вывод категорий ###

В уроке вы водили категории на одиночной записе через `<?php the_category('@bs@'); ?>` и применением фильтра. Я же реализовал несколько иначе (`wp-content/themes/wptest/template-parts/single-sidebar.php`):

```html
<div class="h2">Post categories</div>
<ul class="secondery-navigation">
    <?php foreach ( get_the_category() as $category ): ?>
        <li>
            <a href="<?= esc_url( get_category_link( $category ) ) ?>">
                <?= esc_html( $category->name ) ?>
            </a>
        </li>
    <?php endforeach ?>
</ul>
```

Соответвенно получилось реализовать вывод категорий без использования фильтров - такой вариант допускается или могут быть "подводные камни" с которыми я просто не встретился в конкретном случае?

### Виджет категории (кастомный) ###

На основе стандартного виджета вывода категорий сделал свой (`wp-content/themes/wptest/widgets`). По факту убрал лишнее и повесил на обертку списка фильтр. Вариант реализации приемлем :) или есть что отрефакторить?

### Префиксы при создание кастомного типа записи ###

При создание кастомного типа записи всегда добавлял префикс `wptest_` и переписывал в `'rewrite'`

```php
$args_portfolio   = [
	// ...
	'rewrite'       => [
		'slug' => 'portfolio'
	],
];
register_post_type( 'wptest-portfolio', $args_portfolio );
```

Хотелось бы услышать вашу точку зрения, насколько ли правильно повсеместно использовать префикс (вопрос больше направленный к правильному написанию кода).

Минус такого вариант обнаружил один, при создание шаблонов темы - этот префикс необходимо указывать в название, что несколько "раздувает" названия файлов (`single-wptest-portfolio.php`.

### Связь зарегистрированных таксономий с типом записи ###

Не совсем понял назначение свойства `'taxonomies'`, в документации указывается, что в массив передается зарегестрированные таксономии, которые нужно связать с конкретным типом записи.

Изначально я думал, что таким приемом, на общей странице (`archive`) будет возможность "достучаться" до таксономий, но по итогу таксономии в сайдбаре вывел через:
```php
<?php $terms_type_work = get_terms( 'wptest-type-work' ); ?>
<?php if ( $terms_type_work ) : ?>
    <div class="aside-box">
        <div class="h2">Type work</div>
        <ul class="secondery-navigation">
			<?php foreach ( $terms_type_work as $term ) : ?>
                <li>
                    <a href="<?= get_term_link( $term->term_id ) ?>">
						<?= $term->name ?>
                    </a>
                </li>
			<?php endforeach; ?>
        </ul>
    </div>
<?php endif; ?>

<?php $terms_clients = get_terms( 'wptest-clients' ); ?>
<?php if ( $terms_clients ) : ?>
	<div class="aside-box">
		<div class="h2">Clients</div>
		<ul class="secondery-navigation">
			<?php foreach ( $terms_clients as $term ) : ?>
				<li>
					<a href="<?= get_term_link( $term->term_id ) ?>">
						<?= $term->name ?>
					</a>
				</li>
			<?php endforeach; ?>
		</ul>
	</div>
<?php endif; ?>
```

То есть прямым обращением к конкретной таксономии. Могли бы показать пример, где использование `taxonomies` при регистрации пользовательского типа записи приносит профит? :)

## Вопросы не по уроку ##

### 1 ###

Часто встречал такой прием (в основном в плагинах):

```php
if(!defined('ABSPATH')) {
    exit;
}
```

Если я правильно понял, условие срабатывает при прямом обращение к скрипту. В создаваемой теме, если файлы распологались в поддерикториях, в них я создвал файл-заглушку (index.php). И увидев данный прием не могу понять, что лучше :) - использовать пустой index.php или в скрипте использовать такой условие? Интересно ваше мнение.

### 2 ###

Виджет выводящий php скрипт так и не дает мне покоя :). Как вы правильно сказали - давать возможность писать скрипт в админке (виджете) - серьезная уязвимость. 

Но есть достаточно популярный плагин (более 100 000 скачиваний) [PHP Code Widget](https://wordpress.org/plugins/php-code-widget/). В его файле реализация +/- схожая. Используется `eval()`. Получается устанавлия такой плагин люди сознательно делают "дыру" в безопасности?

Изначально я думал, там будет что-то вроде whitelist / blacklist - но ничего похожего не увидел. И получается, если нужно в виджете исполнить РНР скрипт, то правильном подходом будет - написать свой плагин, который "внутри себя" выполнит скрипт, а на фронт выведет только результат. Правильно? 